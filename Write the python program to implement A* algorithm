import heapq

def a_star(graph, start, goal, heuristic):
    # Priority queue: (f_score, node, path, g_score)
    open_list = [(heuristic[start], start, [start], 0)]
    visited = set()

    while open_list:
        f, current, path, g = heapq.heappop(open_list)

        if current in visited:
            continue
        visited.add(current)

        # Goal reached
        if current == goal:
            return path, g

        # Explore neighbors
        for neighbor, cost in graph[current].items():
            if neighbor not in visited:
                g_new = g + cost
                f_new = g_new + heuristic[neighbor]
                heapq.heappush(open_list, (f_new, neighbor, path + [neighbor], g_new))

    return None, float("inf")


if __name__ == "__main__":
    # Example graph (weighted)
    graph = {
        'A': {'B': 1, 'C': 3},
        'B': {'A': 1, 'D': 3, 'E': 6},
        'C': {'A': 3, 'F': 2},
        'D': {'B': 3},
        'E': {'B': 6, 'F': 1, 'G': 2},
        'F': {'C': 2, 'E': 1, 'G': 4},
        'G': {'E': 2, 'F': 4}
    }

    # Heuristic values (estimated cost to reach goal)
    heuristic = {
        'A': 7,
        'B': 6,
        'C': 4,
        'D': 4,
        'E': 2,
        'F': 2,
        'G': 0   # Goal node has heuristic 0
    }

    start, goal = 'A', 'G'
    path, cost = a_star(graph, start, goal, heuristic)

    print("Optimal Path:", " -> ".join(path))
    print("Total Cost:", cost)
